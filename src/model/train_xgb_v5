#!/usr/bin/env python3
"""
train_gold_model_v5.py
Enhanced Gold-Scalper inspired training pipeline:
- 3-class return classification (-1, 0, +1)
- Bull/Bear regime split
- Profitability-driven stacking ensemble
- Auto-report with profit summary
"""

import pandas as pd
import numpy as np
import os, time, warnings
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import accuracy_score, f1_score, classification_report
from sklearn.ensemble import (
    RandomForestClassifier, GradientBoostingClassifier, StackingClassifier
)
from sklearn.svm import SVC
from sklearn.neural_network import MLPClassifier
from xgboost import XGBClassifier
from sklearn.linear_model import LogisticRegression
import joblib

warnings.filterwarnings("ignore")

DATA_PATH = "./data/final/final_dataset_daily.csv"
MODEL_DIR = "./models"

os.makedirs(MODEL_DIR, exist_ok=True)

# === 1ï¸âƒ£ Load data ===
df = pd.read_csv(DATA_PATH)
print(f"Loaded {len(df)} rows ({df['Date'].iloc[0]} â†’ {df['Date'].iloc[-1]})")

# === 2ï¸âƒ£ Feature prep ===
df['Return'] = df['Close'].pct_change()
df['MA20'] = df['Close'].rolling(20).mean()
df['MA50'] = df['Close'].rolling(50).mean()

# Market regime: bull/bear
df['regime'] = np.where(df['MA20'] > df['MA50'], 'bull', 'bear')

# Classify by return amplitude
df['target'] = np.where(df['Return'] > 0.002, 1,
                 np.where(df['Return'] < -0.002, -1, 0))

df = df.dropna().reset_index(drop=True)

# Features (exclude columns not used)
drop_cols = ['Date','target','regime']
X = df.drop(columns=drop_cols, errors='ignore')
y = df['target']
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# === 3ï¸âƒ£ Split train/test ===
X_train, X_test, y_train, y_test = train_test_split(
    X_scaled, y, test_size=0.2, shuffle=False
)

# === 4ï¸âƒ£ Define base models ===
base_models = {
    "rf": RandomForestClassifier(n_estimators=200, random_state=42),
    "gb": GradientBoostingClassifier(n_estimators=200, learning_rate=0.05),
    "svc": SVC(probability=True, kernel='rbf', C=1.0),
    "mlp": MLPClassifier(hidden_layer_sizes=(64,32), max_iter=500),
    "xgb": XGBClassifier(
        n_estimators=300, learning_rate=0.05, max_depth=5,
        subsample=0.8, colsample_bytree=0.8, objective='multi:softmax',
        num_class=3, random_state=42
    )
}

meta_learner = GradientBoostingClassifier(n_estimators=300, learning_rate=0.05)

# === 5ï¸âƒ£ Train and evaluate per regime ===
reports = []
for regime in ['bull', 'bear']:
    sub_df = df[df['regime'] == regime]
    if len(sub_df) < 200:
        continue

    print(f"\nâš™ï¸ Training regime model: {regime}")
    Xr = sub_df.drop(columns=drop_cols, errors='ignore')
    yr = sub_df['target']
    Xr_scaled = scaler.fit_transform(Xr)

    X_train_r, X_test_r, y_train_r, y_test_r = train_test_split(
        Xr_scaled, yr, test_size=0.2, shuffle=False
    )

    regime_models = {}
    profits = []

    for name, model in base_models.items():
        model.fit(X_train_r, y_train_r)
        y_pred = model.predict(X_test_r)

        acc = accuracy_score(y_test_r, y_pred)
        f1 = f1_score(y_test_r, y_pred, average='macro')

        # pseudo-profit: sum of (predicted * actual)
        profit = np.mean(y_pred * y_test_r)

        print(f"ğŸ§  {name:5s} acc={acc:.3f} f1={f1:.3f} ğŸ’°profit={profit:.3f}")

        reports.append({
            "regime": regime,
            "model": name,
            "acc": acc,
            "f1": f1,
            "profit": profit
        })
        regime_models[name] = model
        profits.append(profit)

    # === stacking ensemble ===
    estimators = [(n, m) for n, m in regime_models.items()]
    stack = StackingClassifier(
        estimators=estimators,
        final_estimator=meta_learner,
        n_jobs=-1
    )
    stack.fit(X_train_r, y_train_r)
    y_pred_s = stack.predict(X_test_r)
    acc_s = accuracy_score(y_test_r, y_pred_s)
    f1_s = f1_score(y_test_r, y_pred_s, average='macro')
    profit_s = np.mean(y_pred_s * y_test_r)

    print(f"âœ… {regime.upper()} STACKED: acc={acc_s:.3f} f1={f1_s:.3f} ğŸ’°profit={profit_s:.3f}")

    joblib.dump(stack, f"{MODEL_DIR}/stack_{regime}_{int(time.time())}.pkl")

    reports.append({
        "regime": regime,
        "model": "stack_ensemble",
        "acc": acc_s,
        "f1": f1_s,
        "profit": profit_s
    })

# === 6ï¸âƒ£ Save report ===
report_df = pd.DataFrame(reports)
ts = time.strftime("%Y%m%d_%H%M%S")
report_path = f"{MODEL_DIR}/gold_model_report_{ts}.csv"
report_df.to_csv(report_path, index=False)

print("\nâœ… All models trained successfully!")
print(f"ğŸ“Š Report saved to: {report_path}")
print(report_df.groupby("regime")[["acc","f1","profit"]].mean())
